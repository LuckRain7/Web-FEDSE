# 三、DOM/BOM 及事件处理机制

## 1. 浏览器底层渲染机制1.有关样式的处理(37)

![浏览器渲染页面的机制和原理](/images/module-1/3/render.png)



**在页面加载的过程中，如果遇到：**

【link 导入外部样式资源】

浏览器会新开辟一个线程，去服务器获取对应的资源文件（不会阻碍主线程的渲染）

【style 内嵌样式】

正常从上到下解析而已（解析完再继续解析 DOM 结构）

【@import 导入样式】（同步）

此时不会新开辟新的线程与加载资源，而是让主线程去获取，这样阻碍了DOM结构的继续渲染

只有等把外部样式导入进来，并且解析后，才会继续渲染DOM结构。



**优化：**

1.  在真实项目中，如果 CSS 样式代码不是很多（再或者是移动端的项目），我们应该使用内嵌式，以此来减少 HTTP 资源的请求，提高页面渲染的速度。

2.  网络资源请求或者 HTTP 请求的最大并发数：大部分浏览器都维持在 6 个左右（为了避免并发上线，页面渲染速度变慢，我们应该尽量减少 HTTP 的请求数量）



![](/images/module-1/3/1-1.png)

## 2. 浏览器磁层渲染机制2：有关JS的处理(38)

![有关JS的处理](/images/module-1/3/2-1.png)

**页面加载中遇到 JS （JS 中会有操作 DOM 的代码）：** 

【默认 Script src=‘xxx’ 】

主线程会从服务器获取到 JS 资源，并且把 JS 资源进行解析加载，加载完成后继续渲染 DOM 结构

【如果设置了 defer 或者 async】

都是让其编程异步获取资源（不会阻碍 DOM 渲染）

- defer 可以遵循原有的加载顺序，获取后按照顺序去一次渲染 JS
- async 无序的，谁先回来就先执行谁



**优化：**

1. 为啥把 link 写在结构的上面，把 script 写在结构的下面？
   - link 放到顶部是为了更快加载回来css
   - script 放到底部是为了获取 DOM 元素或者不阻碍 DOM 渲染

2. 现代浏览器都有完善的代码扫描机制：如果遇到 script 需要同步加载和渲染代码，浏览器在渲染 JS 的时候，同时会向下继续扫描代码，如果发现一些异步的资源代码，此时就开始加载请求了。

**DOMContentLoaded 事件：**当 DOM 结构加载完成就会触发。

DOM 树有了，并且 JS 也执行加载了，此时触发这个事件。

JQuery 中 $(document).ready(function(){}) | $(function(){})原理就是使用 DOMContentLoaded  事件完成。

DOMContentLoaded 在低版本的额浏览器中不兼容，不兼容则使用 onreadystatechange 事件代替，在这个事件中监听 document.readyState 值，值为 complete 代表 DOM 结构加载完成。

```javascript
window.addEventListener('DOMContentLoaded', _ => {
	let navBox = document.getElementById('navBox');
})
```

**load 事件：**当所有资源都加载完成后才触发。

包含了需要等待图片等资源也加载完才触发。



## 3.  浏览器底层渲染机制3： DOM回流和重绘(39)

![浏览器渲染页面的机制和原理](/images/module-1/3/render.png)

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树

2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)

3. Layout(回流): 根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流

4. Painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素

5. Display:将像素发送给GPU，展示在页面上



### DOM的重绘和回流 Repaint & Reflow

- 回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染

​        如添加或删除可见的DOM元素 ; 元素的位置发生变化; 元素的尺寸发生变化; 内容发生变化（比如文本变化或图片被另一个不同尺寸的图片所替代）; 页面一开始渲染的时候（这个无法避免）; 因为回流是根据视口的大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也会引发回流....

- 重绘：元素样式的改变（但宽高、大小、位置等不变）

  如 outline, visibility, color、background-color等

**注意：回流一定会触发重绘，而重绘不一定会回流**



### 前端性能优化之：避免DOM的回流

1.  放弃传统操作dom的时代，基于vue/react开始数据影响视图模式

​       mvvm / mvc / virtual dom / dom diff ......

2.  分离读写操作 （现代的浏览器都有渲染队列的机制）

​       offsetTop、offsetLeft、offsetWidth、offsetHeight、clientTop、clientLeft、clientWidth、clientHeight

scrollTop、scrollLeft、scrollWidth、scrollHeight、getComputedStyle、currentStyle....会刷新渲染队列 

3. 样式集中改变 

​       div.style.cssText = 'width:20px;height:20px;'

​       div.className = 'box';

4.  缓存布局信息（原理还是分离读写）

​       div.style.left = div.offsetLeft + 1 + 'px';   div.style.top = div.offsetTop + 1 + 'px';

​        =>改为

​       var curLeft = div.offsetLeft;  var curTop = div.offsetTop;

​       div.style.left = curLeft + 1 + 'px';  div.style.top = curTop + 1 + 'px';

5.  元素批量修改（原理还是分离读写）

​       文档碎片：createDocumentFragment

​       模板字符串拼接

6.  动画效果应用到 position 属性为 absolute 或 fixed 的元素上（脱离文档流）

7.  CSS3 硬件加速（ PU 加速）

​       比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘；transform \ opacity \ filters ... 这些属性会触发硬件加速，不会引发回流和重绘......

​       可能会引发的坑：过多使用会占用大量内存，性能消耗严重、有时候会导致字体模糊等

8. 牺牲平滑度换取速度

​       每次 1 像素移动一个动画，但是如果此动画使用了 100% 的CPU，动画就会看上去是跳动的，因为浏览器正在与更新回流做斗争。每次移动 3 像素可能看起来平滑度低了，但它不会导致 CPU 在较慢的机器中抖动

9.  避免 table 布局和使用 css 的 javascript 表达式

```javascript
# 读写分离
let navBox = document.getElementById('navBox');

// 渲染队列机制导致引发一次回流（读写分离）
navBox.style.width = '100px';
navBox.style.height = '100px';
console.log(navBox.clientWidth);

// 触发两次
navBox.style.width = '100px';
console.log(navBox.clientWidth);
navBox.style.height = '100px';

// 10次回流
for (let i = 0; i < 10; i++) {
  let span = document.createElement('span');
  navBox.appendChild(span);
}

// 一次回流
// 元素批量修改(文档碎片：createDocumentFragment)
let frag = document.createDocumentFragment();
	for (let i = 0; i < 10; i++) {
		let span = document.createElement('span');
		frag.appendChild(span);
	}
	navBox.appendChild(frag);

// 一次回流
let str = ``;
for (let i = 0; i < 10; i++) {
  str += `<span></span>`;
}
navBox.innerHTML = str;
```



图潘

/images/module-1/3/2-1.png