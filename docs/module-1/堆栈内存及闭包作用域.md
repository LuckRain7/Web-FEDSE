# 堆栈内存及闭包作用于

## 1 JS 的8中数据类型及区别

- 基本数据类型（值类型）
  -  number string boolean null undefined

- 引用数据类型
  - object：{} [] /^$/ 日期对象 Math 实例对象... 
  - function

- ES6中新增
  -  Symbol 唯一值



`typeof` 检测数据类型

```javascript
console.log(typeof NaN); //=>"number"  不是一个有效数字，但是属于number数字类型

// NaN==NaN也是不相等，它和谁都不相等，所以检测是否为有效数字需要用isNaN
isNaN(0)    //false
isNaN('a')  //true
isNaN('10') // false
// 先执行的 number()
```

object

> 1. 对象的属性名可以使基本引用值
>
> 2. 对象的属性名一定不能是引用类型值,默认会把引用类型值转换为字符串进行处理

```javascript
// 默认会把引用类型值转换为字符串进行处理例子：
let a = {
  x: 100
};
let b = function fn() {
  let a = 100;
}
let obj = {
  0: 100,
  true: '珠峰'
};
obj[a] = 1000;
obj[b] = 2000;

// 1. 对象的属性名可以使基本引用值
obj[0] // 100
obj['0'] // 100
obj[true] // 100
obj['true'] // 100

// 2.默认会把引用类型值转换为字符串进行处理
0: 100
[object Object]: 1000
"function fn() {↵ let a = 100;↵ }": 2000
true: "珠峰"
__proto__: Object


// 阿里面试题
let a = {
  x: 100
};
let b = {
  y: 200
};
let obj = {};
obj[a] = '珠峰';
//=>obj["[object Object]"]="珠峰";
obj[b] = "培训";
//=>obj["[object Object]"]="培训";
console.log(obj[a] === obj[b]);  //=>TRUE
```

数组是特殊的对象

```javascript
console.log([12, 23, 34]);
// ↓ 输出
(3) [12, 23, 34]
0: 12
1: 23
2: 34
length: 3
```

## 2  JS 堆栈内存的运行机制

### 知识点

编译器（把代码解析成浏览器看得懂的结构）

- 词法解析 ↓

- AST 抽象语法树 ↓

- 构建出浏览器能执行的代码 ↓

引擎（ V8 / webkit内核 ）

- 变量提升 
- 作用域 / 闭包 
- 变量对象
- 堆栈内存
- GO / VO / AO / EC / ECStack

举例：

![JS堆栈内存的运行机制](/web-fedse/images/module-1/1/JS堆栈内存的运行机制.png)



a = 12 变量赋值的三步操作：

- 1.创建变量： 声明 declare

- 2.创建值：基本值直接在栈中创建和存储即可（**复杂引用值结构使用堆**）

- 3.让变量和值关联起来（赋值） 定义 defined

### 课后题：

- 题1

```javascript
/*阿里面试题 q1.png*/
let a = {
    n: 10
};
let b = a;
b.m = b = {
    n: 20
};
console.log(a);
console.log(b);

// ↓ 输出
{ n: 10 ,m: { n: 20 } } 
{ n: 20 }
// 关键 b.m 先执行  执行时b当时指向 { n: 10 }  =》 { n: 10 ,m: undefined } 
// 然后执行 b = { n: 20 } 修改b的执行
// 再执行 b.m = b  也就是把 { n: 10 ,m: undefined } 中 m 指向了 { n: 20 }
```

![阿里面试题 q1.png](/web-fedse/images/module-1/1/q1.png)

- 题2

```javascript
/*360面试题  q2.png*/
let x = [12, 23];
function fn(y) {
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y);
}
fn(x);
console.log(x);

// ↓ 输出
[100, 200]
[100, 23] // y=[100] 切换了指向 所以23没有变化
// ps: 赋值和改变指向地址的区别
```



![360面试题  q2.png](/web-fedse/images/module-1/1/q2.png)

> ps:函数也是变量，和let和var创建的变量本质是一样的，区别是存储的值是函数类型的值

- 题3

```javascript
var x = 10;
~ function (x) {
    console.log(x);
    x = x || 20 && 30 || 40;
    console.log(x);
}();
console.log(x);

// ↓ 输出

var x = 10;
~ function (x) {
    console.log(x); // 没有传参 arguments ={} x = undefined
    x = x || 20 && 30 || 40;
    console.log(x); // 30
}();
console.log(x); // 10
```



![q3](/web-fedse/images/module-1/1/q3.png)

> Tips:  
>
> A || B  ：A为真，返回A，否则返回B
>
> A && B  ：A为真，返回B，否则返回A
>
> && 优先级高于 || 



- 题4

```javascript
let x = [1, 2],
    y = [3, 4];
~ function (x) {
    x.push('A');
    x = x.slice(0);
    x.push('B');
    x = y;
    x.push('C');
    console.log(x, y);
}(x);
console.log(x, y);

// ↓ 输出
let x = [1, 2],
    y = [3, 4];
~ function (x) {
    x.push('A'); // x = [1, 2, 'A'] （堆AAAFFF000）
    x = x.slice(0); // x = [1, 2, 'A']（会创建并指向克隆堆BBBFFF000）
    x.push('B'); // x = [1, 2, 'A', 'B']（堆BBBFFF000）
    x = y; // 更换指向全局的y（堆BBBFFF111）
    x.push('C'); // x = [3, 4, 'C']（堆BBBFFF111）
    console.log(x, y); // [3, 4, 'C'] [3, 4, 'C'] （堆BBBFFF111）
}(x);
console.log(x, y); // [1, 2, 'A'] [3, 4，'c'] 
// ps: 永远要注意指向问题
```

![q4](/web-fedse/images/module-1/1/q4.png)



- 题5

```javascript
let res = parseFloat('left:200px');
if(res===200){
   alert(200);
}else if(res===NaN){
   alert(NaN);
}else if(typeof res==='number'){
   alert('number');
}else{
   alert('Invalid Number');
}
```





- arguments 在严格和非严格模式下的区别

```javascript
/* 非严格模式 */
function fn(x, y){
  console.log(x, y, arguments)
  arguments[0] = 100
  y = 200
  console.log(x, y, arguments)
}
fn(10, 20)

// 解析
function fn(x, y){
  /*
   * arguments = {0:10,1:20}
   * x = 10
   * y = 20 
   * 形成对应的映射关系（非严格模式）
   */
  console.log(x, y, arguments)
  arguments[0] = 100
  y = 200
  console.log(x, y, arguments)
}
fn(10, 20)
// ↓ 输出
10 20 [10,20]
100 200 [100,200]
```

```javascript
 "use strict"; // 严格模式（阻断了映射规则）
function fn(x, y) {
  console.log(x, y, arguments); //=>10 20 [10,20]
  arguments[0] = 100;
  y = 200;
  console.log(x, y, arguments); //=>10 200 [100,20]
}
fn(10, 20); 
```



## 3  GO/VO/AO/EC及作用域和执行上下文

### 知识点：

GO：全局对象(Global Object) 

EC：Execution Context 执行环境（执行上下文）

- VO：Varibale Object 变量对象
- AO：Activation Object 活动对象 （函数的叫做AO，理解为VO的一个分支）

 ECStack：Execution [ˌeksɪˈkjuːʃn] Context Stack 执行环境栈 

 Scope：作用域，创建的函数的时候就赋予的 

 Scope Chain ：作用域链 



例子：

```javascript
let x = 1;
function A(y){
   let x = 2;
   function B(z){
       console.log(x+y+z);
   }
   return B;
}
let C = A(2);
C(3);

//----------------------------------------------//
/*第一步：创建全局执行上下文，并将其压入ECStack中*/
ECStack = [
    //=>全局执行上下文
    EC(G) = {
        //=>全局变量对象
        VO(G):{
            ... //=>包含全局对象原有的属性
            x = 1;
            A = function(y){...};
            A[[scope]] = VO(G); //=>创建函数的时候就确定了其作用域
        }
    }
];

/*第二步：执行函数A(2)*/
ECStack = [
    //=>A的执行上下文
    EC(A) = {
        //=>链表初始化为：AO(A)->VO(G)
        [scope]:VO(G)
        scopeChain:<AO(A),A[[scope]]>
        //=>创建函数A的活动对象
        AO(A) : {
            arguments:[0:2],
            y:2,
            x:2,
            B:function(z){...},
            B[[scope]] = AO(A);
            this:window;
        }
    },
    //=>全局执行上下文
    EC(G) = {
        //=>全局变量对象
        VO(G):{
            ... //=>包含全局对象原有的属性
            x = 1;
            A = function(y){...};
            A[[scope]] = VO(G); //=>创建函数的时候就确定了其作用域
        }
    }
];

/*第三步：执行B/C函数 C(3)*/
ECStack = [
    //=>B的执行上下文
    EC(B){
        [scope]:AO(A)
        scopeChain:<AO(B),AO(A),B[[scope]]
        //=>创建函数B的活动对象
        AO(B):{
            arguments:[0:3],
            z:3,
            this:window;
        }
    },
    //=>A的执行上下文
    EC(A) = {
        //=>链表初始化为：AO(A)->VO(G)
        [scope]:VO(G)
        scopeChain:<AO(A),A[[scope]]>
        //=>创建函数A的活动对象
        AO(A) : {
            arguments:[0:2],
            y:2,
            x:2,
            B:function(z){...},
            B[[scope]] = AO(A);
            this:window;
        }
    },
    //=>全局执行上下文
    EC(G) = {
        //=>全局变量对象
        VO(G):{
            ... //=>包含全局对象原有的属性
            x = 1;
            A = function(y){...};
            A[[scope]] = VO(G); //=>创建函数的时候就确定了其作用域
        }
    }
];
```

![GOVOAOEC](/web-fedse/images/module-1/1/GOVOAOEC.png)

> ps：沿着栈向下查找，直到全局作用域为止



## 4  闭包作业复习

- 题1

```javascript
let x = 5;
function fn(x) {
    return function(y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7);
fn(8)(9);
f(10);
console.log(x);

// ↓ 输出
let x = 5;
function fn(x) {
    return function(y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7); // x = 7  log:14
fn(8)(9); // log:18
f(10); // x = 8 log:18
console.log(x); // 5
```

图解：

![1.3q1-1](/web-fedse/images/module-1/1/1.3q1-1.png)

![1.3q1-2](/web-fedse/images/module-1/1/1.3q1-2.png)

- 第二题

```javascript
let x = 5;
function fn() {
    return function(y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7);
fn(8)(9);
f(10);
console.log(x);

// --- ↓ 输出 --- 
let x = 5;
function fn() {
    return function(y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7); // ++5 => 6+7 => log:13
fn(8)(9); // 9 + ++6 => log:16
f(10); // 10 + ++7 => log:18
console.log(x); // log:8
```

![1.4-q2](/web-fedse/images/module-1/1/1.4-q2.png)

- 第三题

```javascript
let a=0,
    b=0;
function A(a){
    A=function(b){
        alert(a+b++);
    };
    alert(a++);
}
A(1);
A(2);

// --- ↓ 输出 --- 
let a=0,
    b=0;
function A(a){
    A=function(b){
        alert(a+b++);
    };
    alert(a++);
}
A(1); // '2' x  '1'√
A(2); // '3' x  '4'√
```

![4-q3](/web-fedse/images/module-1/1/4-q3.png)



- 第四题***(做错了)

```javascript
var x = 3,
    obj = {x: 5};
obj.fn = (function () {
    this.x *= ++x;
    return function (y) {
        this.x *= (++x)+y;
        console.log(x);
    }
})();
var fn = obj.fn;
obj.fn(6);
fn(4);
console.log(obj.x, x);

// --- ↓ 输出 --- 
// x知道不到的话去全局变量找
var fn = obj.fn;
// this.x *= ++x; 3*4 = 12 (x=12)
obj.fn(6);
// this.x *= (++x)+y; => 5* (13+6) => 95 （x=13）(this指向obj.x)
// log:13
fn(4);
// this.x *= (++x)+y; => 13*(14+4) => log:234 (x=234)(this指向全局)
console.log(obj.x, x);
// 95 234

```

![4-q4-1](/web-fedse/images/module-1/1/4-q4-1.png)

![4-q4-2](/web-fedse/images/module-1/1/4-q4-2.png)

